"use strict";(self.webpackChunkhb=self.webpackChunkhb||[]).push([[164],{2292:(n,e,s)=>{s.r(e),s.d(e,{comp:()=>i,data:()=>c});var a=s(641);const l={},i=(0,s(6262).A)(l,[["render",function(n,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<h1 id="netcore中使用缓存封装" tabindex="-1"><a class="header-anchor" href="#netcore中使用缓存封装"><span>NetCore中使用缓存封装</span></a></h1><div class="language-C# line-numbers-mode" data-highlighter="prismjs" data-ext="C#"><pre><code><span class="line">    /// &lt;summary&gt;</span>\n<span class="line">    /// 分离 业务逻辑和缓存逻辑  如果都不存在 需要返回null 否则缓存不生效</span>\n<span class="line">    /// &lt;/summary&gt;</span>\n<span class="line">    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;</span>\n<span class="line">    /// &lt;typeparam name=&quot;TKey&quot;&gt;&lt;/typeparam&gt;</span>\n<span class="line">    public abstract class EntityCacheBase&lt;T, TKey&gt; : ITransientService</span>\n<span class="line">    {</span>\n<span class="line">        protected readonly IMemoryCache _cache;</span>\n<span class="line">        protected readonly ILogger&lt;EntityCacheBase&lt;T, TKey&gt;&gt; _logger;</span>\n<span class="line"></span>\n<span class="line">        protected string cacheName = string.Empty; //缓存名称</span>\n<span class="line">        protected TKey cacheKey; //缓存key</span>\n<span class="line">        protected TimeSpan expiryTime = TimeSpan.FromSeconds(60); //缓存时间</span>\n<span class="line">        protected Func&lt;Task&lt;T&gt;&gt; func = null; //具体方法</span>\n<span class="line"></span>\n<span class="line">        protected EntityCacheBase(</span>\n<span class="line">)</span>\n<span class="line">        {</span>\n<span class="line">            // 可切换 redis 单例</span>\n<span class="line">            _cache = new MemoryCache(new MemoryCacheOptions());</span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line">        }</span>\n<span class="line"></span>\n<span class="line">        /// &lt;summary&gt;</span>\n<span class="line">\t\t/// 子类通知需要重写 override 程序运行开始时加载实体监听函数，在数据库实体发生变化时，删除当前缓存</span>\n<span class="line">\t\t/// &lt;/summary&gt;</span>\n<span class="line">        public virtual void ListenEntity()</span>\n<span class="line">        {</span>\n<span class="line">            return;  //监听实体变化 更新缓存</span>\n<span class="line">        }</span>\n<span class="line"></span>\n<span class="line">        public virtual async Task&lt;T&gt; GetAsync(TKey key)</span>\n<span class="line">        {</span>\n<span class="line">            try</span>\n<span class="line">            {</span>\n<span class="line">                cacheKey = key;</span>\n<span class="line">                return await _cache.GetOrCreateAsync(cacheName + cacheKey.ToString(), async cacheEntry =&gt;</span>\n<span class="line">                {</span>\n<span class="line">                    cacheEntry.AbsoluteExpirationRelativeToNow = expiryTime;</span>\n<span class="line">                    if (func == null)</span>\n<span class="line">                    {</span>\n<span class="line">                        throw new InvalidOperationException(&quot;The &#39;func&#39; delegate must be set before calling GetAsync.&quot;);</span>\n<span class="line">                    }</span>\n<span class="line">                    return await func();</span>\n<span class="line">                }) ?? throw new InvalidOperationException(&quot;The cache returned a null value.&quot;);</span>\n<span class="line">            }</span>\n<span class="line">            catch (Exception ex)</span>\n<span class="line">            {</span>\n<span class="line">                _logger?.LogError(ex, &quot;Error in GetAsync for key {Key}: {Message}&quot;, key, ex.Message);</span>\n<span class="line">                throw new InvalidOperationException(&quot;Error in GetAsync: &quot; + ex.Message);</span>\n<span class="line">            }</span>\n<span class="line">        }</span>\n<span class="line"></span>\n<span class="line">        public void Remove(TKey key)</span>\n<span class="line">        {</span>\n<span class="line">            _cache.Remove(cacheName + key.ToString());</span>\n<span class="line">        }</span>\n<span class="line">    }</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用方式" tabindex="-1"><a class="header-anchor" href="#使用方式"><span>使用方式</span></a></h3><blockquote><p>例如我们这个缓存为用户缓存逻辑,我们继承 EntityCacheBase &lt;响应结果实体,传入key的类型&gt; UserRoleCacheService 在其他地方进行构造函数注入,进行使用</p></blockquote><pre><code>/// &lt;summary&gt;\n/// 用户缓存\n/// &lt;/summary&gt;\npublic class UserRoleCacheService : EntityCacheBase&lt;List&lt;UserRoleItem&gt;, int&gt;\n{\n\n    private readonly IMysqlSqlSugarClient _mysqlSqlSugarClient;\n    public UserRoleCacheService(IMysqlSqlSugarClient mysqlSqlSugarClient)\n    {\n        _mysqlSqlSugarClient = mysqlSqlSugarClient;\n\n        cacheName = &quot;user:&quot;;\n        expiryTime = TimeSpan.FromHours(1);\n        func = async () =&gt;\n        {\n            var item = await _mysqlSqlSugarClient.Queryable&lt;User&gt;()\n                      .Where(x =&gt; x.IsDeleted == EntityStatusEnums.Normal)\n                      .Where(x =&gt; x.Id == cacheKey)\n                      .FirstAsync();\n            if (item == null)\n            {\n                return null;\n            }\n            var result = await _mysqlSqlSugarClient.Queryable&lt;UserRole&gt;()\n                       .LeftJoin&lt;Role&gt;((a, b) =&gt; a.RoleId == b.RoleId)\n                       .Where((a, b) =&gt; a.UserId == item.Id)\n                       .Where((a, b) =&gt; a.IsDeleted == EntityStatusEnums.Normal &amp;&amp;\n                        b.IsDeleted == EntityStatusEnums.Normal)\n                       .Select((a, b) =&gt; new\n                       {\n                           RoleName = b.RoleName,\n                           RoleId = b.RoleId,\n                           UserId = a.UserId,\n                           b.Permissions,\n                           // b.IsDeleted\n                       })\n                       .ToListAsync();\n            var items = result.Select(x =&gt;\n            {\n                var v = new UserRoleItem();\n                v.RoleName = x.RoleName;\n                v.RoleId = x.RoleId;\n                v.UserId = x.UserId;\n                v.Permissions = x.Permissions ?? &quot;&quot;;\n                return v;\n            }).ToList();\n            return items;\n        };\n    }\n}\n</code></pre>',5)]))}]]),c=JSON.parse('{"path":"/Net/Cache.html","title":"NetCore中使用缓存封装","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"使用方式","slug":"使用方式","link":"#使用方式","children":[]}],"git":{"updatedTime":1753688916000,"contributors":[{"name":"TuCoke","username":"TuCoke","email":"57646826+TuCoke@users.noreply.github.com","commits":3,"url":"https://github.com/TuCoke"}],"changelog":[{"hash":"1a2b04ab982cd830a775d1b5b3479004c3713d29","time":1753688916000,"email":"57646826+TuCoke@users.noreply.github.com","author":"subman","message":"Rename Cache to Cache.md"},{"hash":"c0f24f09752239e2699db7c8e310a219f0eb5a1a","time":1753688729000,"email":"57646826+TuCoke@users.noreply.github.com","author":"subman","message":"Update Cache"},{"hash":"c1521e330a407c708e86f7cf63a0a4243dd700bc","time":1753688233000,"email":"57646826+TuCoke@users.noreply.github.com","author":"subman","message":"Create Cache"}]},"filePathRelative":"Net/Cache.md"}')}}]);